/*
 * $Id$
 * 
 * Copyright (c) 2019 Aero Systems Indonesia, PT.
 * All rights reserved.
 * 
 * AERO SYSTEMS INDONESIA PROPRIETARY/CONFIDENTIAL. Use is subject to
 * license terms.
 */
package id.co.asyst.bukopin.mobile.user.web.rest;

import java.net.URISyntaxException;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import id.co.asyst.bukopin.mobile.common.core.util.BkpmUtil;
import id.co.asyst.bukopin.mobile.common.core.util.CryptoUtil;
import id.co.asyst.bukopin.mobile.common.core.util.MessageUtil;
import id.co.asyst.bukopin.mobile.common.model.ResponseMessage;
import id.co.asyst.bukopin.mobile.common.model.payload.CommonRequest;
import id.co.asyst.bukopin.mobile.common.model.payload.CommonResponse;
import id.co.asyst.bukopin.mobile.user.core.service.UserTokenService;
import id.co.asyst.bukopin.mobile.user.model.payload.VerifyPhoneOwnerRequest;
import id.co.asyst.bukopin.mobile.user.model.payload.VerifyTokenOwnerRequest;
import id.co.asyst.bukopin.mobile.user.model.payload.VerifyTokenOwnerResponse;
import id.co.asyst.bukopin.mobile.user.model.security.UserToken;


/**
 * REST Controller for managing UserToken.
 * 
 * @author Stephen Dharma
 * @version $Revision$,(Created on Oct 24, 2019)
 * @since 1.0.Alpha1
 */
@RestController
@RequestMapping("/api")
public class UserTokenController {
	/**
     * Logger.
     */
    private final Logger log = LoggerFactory.getLogger(UserTokenController.class);

    /* Constants: */

    /* Attributes: */

    /* Services: */
    /**
     * User Repository (auto-wired, this means to get the bean called
     * <code>userTokenRepository</code>. Which is auto-generated by Spring, we will
     * use it to handle the data).
     */
    @Autowired
    private UserTokenService userTokenService;
    
    /**
     * Get Message Util
     */
    @Autowired
    private MessageUtil messageUtil;
    
    /**
     * Http Servlet Request
     */
    @Autowired
    private HttpServletRequest httpServletRequest;

    /* Constructors: */
    /**
     * Default Constructor.
     */
    public UserTokenController() {
        // do nothing.
    }

    /* Getters & setters for attributes: */

    /* Functions: */
    /**
     * GET /userTokens : get all userTokens.
     *
     * @return the response with status 200 (OK) and the list of userTokens in body.
     */
    @GetMapping("/userTokens")
    public List<UserToken> getAllUserTokens() {
        log.debug("REST request to get UserTokens");
        return userTokenService.findAll();
    }

    /**
     * POST /userTokens : Creates a new UserToken.
     *
     * @param userToken The userToken to create.
     * @return The response with status 201 (Created) and with body of the new
     * UserToken, or with status 400 (Bad Request) if the userToken has already an ID.
     */
    @PostMapping("/userTokens")
    @ResponseStatus(HttpStatus.CREATED)
    public UserToken createUserToken(@Valid @RequestBody UserToken userToken) throws URISyntaxException {
        log.debug("REST request to save UserToken : {}", userToken);
        if (userToken.getId() != null) {
            // throw new BadRequestAlertException("A new userToken cannot already have an
            // ID", "UserToken", "idexists");
        }
        return userTokenService.save(userToken);
    }

    /**
     * PUT /userTokens : Updates an existing UserToken.
     *
     * @param userToken The UserToken to update.
     * @return The response with status 200 (OK) and with body the updated
     * userToken,<br>
     * or with status 400 (Bad Request) if the userToken is not valid,<br>
     * or with status 500 (Internal Server Error) if the userToken couldn't be
     * updated.
     */
    @PutMapping("/userTokens")
    @ResponseStatus(HttpStatus.OK)
    public UserToken updateUserToken(@Valid @RequestBody UserToken userToken) throws URISyntaxException {
        log.debug("REST request to update UserToken : {}", userToken);
        if (userToken.getId() == null) {
            // throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
        }
        return userTokenService.save(userToken);
    }

    /**
     * DELETE /userTokens/:id : delete the "id" UserToken.
     *
     * @param id The ID of the UserToken to delete.
     * @return The response with status 200 (OK).
     */
    @DeleteMapping("/userTokens/{id}")
    @ResponseStatus(HttpStatus.OK)
    public void deleteUserToken(@PathVariable String id) {
        log.debug("REST request to delete UserTOken : {}", id);
        userTokenService.delete(id);
    }
    
    @PostMapping("/userToken/getByToken")
    public CommonResponse findUserToken(@RequestBody UserToken token) {
        log.debug("REST request to get UserToken by token "+token);
        CommonResponse response = new CommonResponse(ResponseMessage.SUCCESS.getCode(), messageUtil.get("success", httpServletRequest.getLocale()));
        UserToken userToken = userTokenService.findByToken(token.getToken());    	
    	log.debug("userToken "+userToken);
		if (null != userToken) {
			response.setData(userToken);		    
		}else {
			response.setCode(ResponseMessage.DATA_NOT_FOUND.getCode());
		    response.setMessage(messageUtil.get("error.data.not.found", httpServletRequest.getLocale()));
		}
    			
        return response;
    }
    
    /**
     * Verify Token Owner
     * 
     * @param request
     *            The request contains Username and Token.
     * @return Http Status 200 with body contains value of "valid" true if Owner and
     *         Token valid, else "valid" value is false. If success, in
     *         body will contains User and UserToken.
     */
    @PostMapping("/verifyTokenOwner")
    @ResponseStatus(HttpStatus.OK)
    public CommonResponse verifyTokenOwner(@Valid @RequestBody 
	    CommonRequest<VerifyTokenOwnerRequest> request) {
	CommonResponse response = new CommonResponse(ResponseMessage.SUCCESS.getCode(),
		messageUtil.get("success", httpServletRequest.getLocale()));
	
	String username = request.getData().getUsername();
	String token = request.getData().getToken();
	
	VerifyTokenOwnerResponse data = userTokenService.verifyTokenOwner(username, token);
	response.setData(data);
	
	return response;
    }
    
    /**
     * Verify Token and Phone Owner
     * 
     * @param request
     *            The request contains Username and Token.
     * @return Http Status 200 with body contains value of "valid" true if Owner and
     *         Token valid, else "valid" value is false. If success, in
     *         body will contains User and UserToken.
     *         
     * **note: no need header params like Authorization for this service.
     */
    @PostMapping("/verifyPhoneOwner")
    @ResponseStatus(HttpStatus.OK)
    public CommonResponse verifyPhoneOwner(@Valid @RequestBody 
	    CommonRequest<VerifyPhoneOwnerRequest> request) {
	CommonResponse response = new CommonResponse(ResponseMessage.SUCCESS.getCode(),
		messageUtil.get("success", httpServletRequest.getLocale()));
	
	String username = request.getData().getUsername();
	String token = request.getData().getToken();
	String phoneId = request.getData().getPhoneIdentity();
	
	VerifyTokenOwnerResponse data = userTokenService.verifyTokenAndPhoneOwner(username, token, phoneId);
	response.setData(data);
	
	return response;
    }
    
    /**
     * GET /validateSession: Validate Login Session
     * 
     * @param token The encrypted (AES Hex) login token.
     * @return true if session still alive, else false.
     * @throws Exception 
     */
    @GetMapping("/validateSession/{token}")
    @ResponseStatus(HttpStatus.OK)
    public CommonResponse validateLoginSession(@PathVariable String token) throws Exception {
	String decryptedToken = CryptoUtil.decryptAESHex(token);
	CommonResponse response = userTokenService.validateLogginSession(
		decryptedToken, httpServletRequest.getLocale());
	return response;
    }

    /* Overrides: */
}
